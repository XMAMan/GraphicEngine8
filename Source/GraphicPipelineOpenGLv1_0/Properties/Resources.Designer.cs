//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GraphicPipelineOpenGLv1_0.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("GraphicPipelineOpenGLv1_0.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die struct LightStruct
        ///{
        ///	int LightCount;
        ///	vec3 LightPositions[10];
        ///	float ConstantAttenuation[10];
        ///	float LinearAttenuation[10];
        ///	float QuadraticAttenuation[10];
        ///	vec3 SpotDirection[10];			// Richtung bei Richtungslicht
        ///	float SpotCosCutoff[10];			// Wenn 180, dann Punktlicht in alle Richtung, sonst Richtungslicht
        ///	float SpotExponent[10];
        ///	float SpecularHighlightPowExponent;	//Glanzpunktgröße	
        ///};
        /// 
        ///uniform LightStruct lightStruct;
        ///
        /////-------------------------------------------------------------- [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string CommonShaderFunctions {
            get {
                return ResourceManager.GetString("CommonShaderFunctions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //Dieser Shader funktioniert nur wenn man auch den TriangleDrawerNewWay verwendet. Sonst bekommt man ein schwarzes Bild.
        /////Ich könnte mit diesen Shader theoretisch auch Linien und Punkte zeichnen aber dann müsste ich die Linien/Punkte-Daten in VBOs speichern
        /////https://www.geeks3d.com/20111111/simple-introduction-to-geometry-shaders-glsl-opengl-tutorial-part1/ -&gt; So geht ein Pass-Thourgh-Geometry-Shader
        /////http://www.mbsoftworks.sk/index.php?page=tutorials&amp;series=1&amp;tutorial=17
        ///
        ///#version 330
        ///
        /////#version [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string GeometryShader {
            get {
                return ResourceManager.GetString("GeometryShader", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //PixelShader Shadowmap-Creation New Way
        /////#version 330 core
        /// 
        ///smooth in vec2 textcoord;
        ///smooth in vec4 pos;
        ///
        ///// Ouput data
        /////layout(location = 0) out float fragmentdepth; // Ausgabe landet im Framebuffer an Texutur 0 (sie landet NICHT in der Tiefenpuffertextur).
        ///											  // Dafür sorgt die Grafikpipline automatisch, sobald ein Pixel den Pixelshader ohne Discard verläßt. Welche Farbe er dabei hat ist egal.
        ///
        /////layout(location = 0) out vec4 out_frag_color;
        ///
        ///uniform sampler2D Texture0;	// Farbt [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderCreateShadowmap {
            get {
                return ResourceManager.GetString("PixelShaderCreateShadowmap", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //#version 330 core
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform int UseTexture0; 
        ///uniform int BlendingWithBlackColor;
        ///uniform int MouseHitId;
        ///uniform vec4 color;
        ///
        ///smooth in vec2	textcoord;
        ///
        ///void main()
        ///{	
        ///	vec4 objektColor = color * (1.0 - UseTexture0) + vec4(texture2D(Texture0, textcoord.xy)) * UseTexture0 * color;	
        ///	if (BlendingWithBlackColor == 1 &amp;&amp; (objektColor.x + objektColor.y + objektColor.z) &lt; 0.1) discard; 
        ///
        ///	gl_FragColor = vec4(MouseHitId / 255.0f, MouseHitId / 255.0f, MouseH [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderMouseHitTest {
            get {
                return ResourceManager.GetString("PixelShaderMouseHitTest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330 core
        ///
        ///uniform mat4 CameraMatrix;
        ///uniform mat4 NormalMatrix;
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform sampler2D Texture1; // Bumpmap
        ///uniform samplerCube Cubemap;// Für Reflektion
        ///uniform sampler2D ShadowMap;// Shadowmapping
        ///uniform int UseTexture0; 
        ///uniform int UseTexture1; 
        ///uniform int LightingIsEnabled; 
        ///uniform int UseCubemap; 
        ///uniform int UseShadowmap;
        ///uniform int DoFlatShading;
        ///uniform int BlendingWithBlackColor;
        ///uniform vec4 color;
        ///uniform int CullFaceIsEnabled;        /// [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderNormal {
            get {
                return ResourceManager.GetString("PixelShaderNormal", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //#version 330
        ///
        ///uniform mat4 CameraMatrix;
        ///uniform mat4 NormalMatrix;
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform sampler2D Texture1; // Bumpmap
        ///uniform samplerCube Cubemap;// Für Reflektion
        ///uniform sampler2D ShadowMap;// Shadowmapping
        ///uniform int UseTexture0; 
        ///uniform int UseTexture1; 
        ///uniform int LightingIsEnabled; 
        ///uniform int UseCubemap; 
        ///uniform int UseShadowmap;
        ///uniform int DoFlatShading;
        ///uniform int BlendingWithBlackColor;
        ///uniform vec4 color;
        ///uniform int LightCount;
        ///uniform i [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderParallax {
            get {
                return ResourceManager.GetString("PixelShaderParallax", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //VertexShader Shadowmap-Creation New Way
        ///#version 330
        ///
        ///precision highp float;
        ///
        ///uniform mat4 ShadowMapMatrix[10];		//Position, Ausrichtung, Projektionsmatrix und beim Auslesen der ShadowMap Bias-Matrix (Für jede Lichtquelle eine Matrix)
        ///uniform int ShadowmappingTextureId;
        ///uniform mat3 TextureMatrix;
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3) in vec2 in_textcoord;
        ///
        ///out vec2 textcoord;
        ///out  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderCreateShadowmap {
            get {
                return ResourceManager.GetString("VertexShaderCreateShadowmap", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //VertexShader Shadowmap-Creation Old Way
        ///uniform mat4 ShadowMapMatrix[10];
        ///uniform mat3 TextureMatrix;
        ///
        ///smooth out vec4 pos;
        ///smooth out vec2					textcoord;
        ///
        ///void main() 
        ///{
        ///	gl_Position = ShadowMapMatrix[0] * gl_Vertex;
        ///	gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
        ///	pos = ShadowMapMatrix[0] * gl_Vertex;
        ///	textcoord = (TextureMatrix * vec3(gl_MultiTexCoord0.xy, 1)).xy;
        ///
        ///} ähnelt.
        /// </summary>
        internal static string VertexShaderCreateShadowmapOldWay {
            get {
                return ResourceManager.GetString("VertexShaderCreateShadowmapOldWay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die uniform mat3 TextureMatrix;
        ///
        ///smooth out vec2					textcoord;
        ///
        ///void main() 
        ///{
        ///	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;//ftransform();
        ///	gl_FrontColor = gl_Color;
        ///	gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
        ///	textcoord = (TextureMatrix * vec3(gl_MultiTexCoord0.xy, 1)).xy;
        ///} ähnelt.
        /// </summary>
        internal static string VertexShaderMouseHitOldWay {
            get {
                return ResourceManager.GetString("VertexShaderMouseHitOldWay", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3) in vec2 in_textcoord;
        ///
        ///uniform mat4 ObjToClipMatrix;
        ///uniform mat4 ObjToWorldMatrix;
        ///uniform mat4 NormalMatrix;
        ///uniform mat4 ShadowMapMatrix[10];
        ///uniform float TexturScaleFaktorX;
        ///uniform float TexturScaleFaktorY;
        ///
        /////Wenn der Geometry-Shader alles macht
        ///noperspective out vec3			Vnormal;
        ///noperspective out vec3			Vtangent;
        ///smooth out  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderMouseHitTest {
            get {
                return ResourceManager.GetString("VertexShaderMouseHitTest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die //Das ist der aktuell genutzt Geometry-Shader. Der GeometryShader.txt-Shader für den Explosionseffekt geht nicht
        /////#version 330 //-&gt; Wenn ich dieses Attribut nutzen will, muss ich die Vertex-Attribut über layout-Location angeben
        ///
        ///// Vertex-Variablen (Vertexshader-Input)
        ///attribute vec3 in_tangent;		//The inverse tangent to the geometry
        ///
        ///uniform mat4 ObjToClipMatrix;
        ///uniform mat4 ObjToWorldMatrix;
        ///uniform mat4 NormalMatrix;
        ///uniform mat4 ShadowMapMatrix[10];
        ///uniform mat3 TextureMatrix;
        ///
        ///noperspecti [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderNoGeometryBehind {
            get {
                return ResourceManager.GetString("VertexShaderNoGeometryBehind", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330 //-&gt; Wenn ich dieses Attribut nutzen will, muss ich die Vertex-Attribut über layout-Location angeben
        ///
        ///// Vertex-Variablen (Vertexshader-Input)
        /////attribute vec3 in_tangent;		//The inverse tangent to the geometry
        ///
        /////Alter Weg der Texturattribut-Übergabe. Führt dazu gesamtes Dreieck nur eine Texturkoordiante hat.
        /////attribute vec3 in_position;
        /////attribute vec3 in_normal;
        /////attribute vec3 in_tangent;
        /////attribute vec3 in_textcoord;
        ///
        /////Wenn man #version 330 nutzt. Geht nicht. Liefert ein we [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderNormal {
            get {
                return ResourceManager.GetString("VertexShaderNormal", resourceCulture);
            }
        }
    }
}
