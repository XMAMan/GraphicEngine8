//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GraphicPipelineOpenGLv3_0.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("GraphicPipelineOpenGLv3_0.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die uniform int CullFaceIsEnabled;
        ///uniform mat4 CameraMatrix;
        ///
        /////---------------------------------------------------------------------------------------
        ///// Transforms a normal map sample to world space.
        /////---------------------------------------------------------------------------------------
        ///vec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormalW, vec3 tangentW)
        ///{    
        ///	// Uncompress each component from [0,1] to [-1,1].
        ///    vec3 normalT = 2.0f*normalMapSample - 1.0;    // Build orthonormal  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string CommonShaderFunctions {
            get {
                return ResourceManager.GetString("CommonShaderFunctions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///layout(triangles) in;
        ///layout(triangle_strip, max_vertices = 3)out;
        ///
        ///noperspective in vec3 normalPass[];
        ///in vec3 posWorldPass[];
        ///noperspective in vec3 tangentPass[]; 
        ///in vec2 textcoordPass[];
        ///in vec4 ShadowCoordPass[];
        ///
        ///noperspective out vec3 normal;
        ///smooth out vec3 posWorld;
        ///noperspective out vec3 tangent;
        ///smooth out vec2 textcoord;
        ///smooth out vec4 ShadowCoord;
        ///
        ///uniform mat4 ObjToClipMatrix;
        ///uniform mat4 ObjToWorldMatrix;
        ///uniform mat4 NormalMatrix;
        ///uniform mat4 ShadowMapMat [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string GeometryShader {
            get {
                return ResourceManager.GetString("GeometryShader", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330 core
        /// 
        ///smooth in vec2 textcoord;
        ///smooth in vec4 pos;
        ///
        ///// Ouput data
        /////layout(location = 0) out float fragmentdepth; // Ausgabe landet im Framebuffer an Texutur 0 (sie landet NICHT in der Tiefenpuffertextur).
        ///											  // Dafür sorgt die Grafikpipline automatisch, sobald ein Pixel den Pixelshader ohne Discard verläßt. Welche Farbe er dabei hat ist egal.
        ///
        ///layout(location = 0) out vec4 out_frag_color;
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform int UseTexture0; 
        ///uniform int  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderCreateShadowMap {
            get {
                return ResourceManager.GetString("PixelShaderCreateShadowMap", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330 core
        ///
        ///precision highp float;
        ///
        ///smooth in vec2 textcoord;
        ///
        ///layout(location = 0) out vec4 out_frag_color;
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform sampler2D Texture1; // Bumpmap
        ///uniform int UseTexture0; 
        ///uniform int UseTexture1; 
        ///uniform int BlendingWithBlackColor;
        ///uniform vec4 color;
        ///uniform int MouseHitId;
        ///
        ///void main()
        ///{
        ///	vec4 objektColor = color * (1.0 - UseTexture0) + vec4(texture2D(Texture0, textcoord.xy)) * UseTexture0 * color;	
        ///
        ///	if (BlendingWithBlackColor == 1 [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderMouseHitTest {
            get {
                return ResourceManager.GetString("PixelShaderMouseHitTest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330 core
        ///
        ///precision highp float;
        ///
        /////http://www.geeks3d.com/20130514/opengl-interpolation-qualifiers-glsl-tutorial/ -&gt; Für Texturkoordianten braucht man auf jeden fall perpektifische Divsion(smooth)
        /////flat: the value is not interpolated. The value given to the fragment shader is the value from the Provoking Vertex for that primitive. -&gt; Das Provoking-Vertex ist das Vertex des Dreiecks, welches als Input-Parameter für den PixelShader genommen wird. Siehe -&gt; glProvokingVertex — specifiy the verte [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderNormal {
            get {
                return ResourceManager.GetString("PixelShaderNormal", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///precision highp float;
        ///
        ///noperspective in vec3 normal;
        ///in vec3 posWorld;
        ///noperspective in vec3 tangent;
        ///in vec2 textcoord;
        ///smooth in vec4 ShadowCoord;
        ///
        ///layout(location = 0) out vec4 out_frag_color;
        ///
        ///uniform sampler2D Texture0;	// Farbtextur
        ///uniform sampler2D Texture1; // Bumpmap
        ///uniform sampler2D ShadowMap;// Für Shadowmapping
        ///uniform int UseTexture0; 
        ///uniform int UseTexture1; 
        ///uniform int LightingIsEnabled; 
        ///uniform int DoFlatShading;
        ///uniform int UseShadowmap;
        ///uniform int B [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string PixelShaderParallax {
            get {
                return ResourceManager.GetString("PixelShaderParallax", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///precision highp float;
        ///
        ///uniform mat4 ShadowMapMatrix[10];		//Position, Ausrichtung, Projektionsmatrix und beim Auslesen der ShadowMap Bias-Matrix (Für jede Lichtquelle eine Matrix)
        ///uniform int ShadowmappingTextureId;
        ///uniform mat3 TextureMatrix;
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3) in vec2 in_textcoord;
        ///
        ///out vec2 textcoord;
        ///out vec4 pos;
        ///
        ///void main() 
        ///{
        ///   gl_Positio [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderCreateShadowMap {
            get {
                return ResourceManager.GetString("VertexShaderCreateShadowMap", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///precision highp float;
        ///
        ///uniform mat4 ObjToClipMatrix;
        ///uniform mat3 TextureMatrix;
        ///uniform int MouseHitId;
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3) in vec2 in_textcoord;
        ///
        ///out vec2 textcoord;
        ///
        ///void main() 
        ///{
        ///	gl_Position = ObjToClipMatrix * vec4(in_position, 1);
        ///	textcoord = (TextureMatrix * vec3(in_textcoord.xy, 1)).xy;
        ///} ähnelt.
        /// </summary>
        internal static string VertexShaderMouseHitTest {
            get {
                return ResourceManager.GetString("VertexShaderMouseHitTest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///precision highp float;
        ///
        ///uniform mat4 ShadowMapMatrix[10];		//Position, Ausrichtung, Projektionsmatrix und beim Auslesen der ShadowMap Bias-Matrix (Für jede Lichtquelle eine Matrix)
        ///uniform int ShadowmappingTextureId;
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3) in vec2 in_textcoord;
        ///
        ///noperspective out vec3 normalPass;
        ///out vec3 posWorldPass;
        ///noperspective out vec3 tangentPass;         /// [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderNormal {
            get {
                return ResourceManager.GetString("VertexShaderNormal", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die #version 330
        ///
        ///precision highp float;
        ///
        ///uniform mat4 ObjToClipMatrix;
        ///uniform mat4 ObjToWorldMatrix;
        ///uniform mat4 NormalMatrix;
        ///uniform mat3 TextureMatrix;
        ///
        ///uniform mat4 ShadowMapMatrix[10];		//Position, Ausrichtung, Projektionsmatrix und beim Auslesen der ShadowMap Bias-Matrix (Für jede Lichtquelle eine Matrix)
        ///uniform int ShadowmappingTextureId;
        ///
        ///layout (location = 0) in vec3 in_position;
        ///layout (location = 1) in vec3 in_normal;
        ///layout (location = 2) in vec3 in_tangent;
        ///layout (location = 3)  [Rest der Zeichenfolge wurde abgeschnitten]&quot;; ähnelt.
        /// </summary>
        internal static string VertexShaderParallax {
            get {
                return ResourceManager.GetString("VertexShaderParallax", resourceCulture);
            }
        }
    }
}
